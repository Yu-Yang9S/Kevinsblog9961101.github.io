<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>学习笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="学习到JAVESE阶段">
<meta property="og:type" content="website">
<meta property="og:title" content="学习笔记">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="学习笔记">
<meta property="og:description" content="学习到JAVESE阶段">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kevin Yang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="学习笔记" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">学习笔记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">从开始到放弃</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-javase基础/junit-反射-注解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/28/javase%E5%9F%BA%E7%A1%80/junit-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2023-05-28T01:27:06.000Z" itemprop="datePublished">2023-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/28/javase%E5%9F%BA%E7%A1%80/junit-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/">junit-反射-注解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h1><h2 id="1-1-使用步骤"><a href="#1-1-使用步骤" class="headerlink" title="1.1.使用步骤"></a>1.1.使用步骤</h2><ul>
<li>把junit框架的jar包导入项目中(IDEA自动集成了)</li>
<li>对测试的业务类协商对应的测试方法(公共\无参\无返回值)</li>
<li>测试方法上注明@Test</li>
<li>在测试方法上右键选择junit运行,通过成功是绿色,失败是红色</li>
</ul>
<h2 id="1-2-单元测试断言"><a href="#1-2-单元测试断言" class="headerlink" title="1.2.单元测试断言"></a>1.2.单元测试断言</h2><p>Assert.AssertEquals(“内容不符合预期提示信息”,预期值,变量名字)</p>
<h2 id="1-3-单元测试注解"><a href="#1-3-单元测试注解" class="headerlink" title="1.3.单元测试注解"></a>1.3.单元测试注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td></td>
</tr>
<tr>
<td>@Before</td>
<td>修饰实例方法,在每个测试方法执行前执行一次</td>
</tr>
<tr>
<td>@After</td>
<td>修饰实例方法,在每个测试方法执行后执行一次</td>
</tr>
<tr>
<td>@BeforeClass</td>
<td>修饰静态方法,在每个测试方法执行前执行一次</td>
</tr>
<tr>
<td>@AfterClass</td>
<td>修饰静态方法,在每个测试方法执行后执行一次</td>
</tr>
</tbody></table>
<h1 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a>2.反射</h1><p>反射技术，指的是加载类的字节码到内存，并以编程的方法解刨出类中的各个成分（成员变量、方法、构造器等）。</p>
<h2 id="2-1-获得类的字节码"><a href="#2-1-获得类的字节码" class="headerlink" title="2.1.获得类的字节码"></a>2.1.获得类的字节码</h2><p>对象名.getClass</p>
<h2 id="2-2-获得构造器"><a href="#2-2-获得构造器" class="headerlink" title="2.2.获得构造器"></a>2.2.获得构造器</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor&lt;?&gt;[] getConstructors()</td>
<td>获得pub修饰的构造器</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[] getDeclaredConstructors()</td>
<td>获得所有构造器</td>
</tr>
<tr>
<td>Constructor<T> getConstroctor(Class&lt;?&gt; parameterTypes)</td>
<td>获得pub修饰的某个</td>
</tr>
<tr>
<td>Constructor<T> getDeclaredConstroctor(Class&lt;?&gt; parameterTypes)</td>
<td>获得某个构造器</td>
</tr>
</tbody></table>
<p>对象.getDeclaredConstructor(String.class,int.class);</p>
<h2 id="2-3-获取成员变量并使用"><a href="#2-3-获取成员变量并使用" class="headerlink" title="2.3.获取成员变量并使用"></a>2.3.获取成员变量并使用</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getFields()</td>
<td></td>
</tr>
<tr>
<td>getDeclaredFields()</td>
<td></td>
</tr>
<tr>
<td>getField(String name)</td>
<td></td>
</tr>
<tr>
<td>getDeclaredField(String name)</td>
<td></td>
</tr>
</tbody></table>
<p>获取私有变量后使用需要setAccessible(true)才能使用</p>
<h2 id="2-4-获取成员方法并使用"><a href="#2-4-获取成员方法并使用" class="headerlink" title="2.4.获取成员方法并使用"></a>2.4.获取成员方法并使用</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getMethods()</td>
<td></td>
</tr>
<tr>
<td>getDeclaredMethods()</td>
<td></td>
</tr>
<tr>
<td>getMethod(String name)</td>
<td></td>
</tr>
<tr>
<td>getDeclaredMethod(String name)</td>
<td></td>
</tr>
</tbody></table>
<p>获取私有变量后使用需要setAccessible(true)才能使用</p>
<h1 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h1><p>Java注解是代码中的特殊标记，比如@Override、@Test等，作用是：让其他程序根据注解信息决定怎么执行该程序。</p>
<h2 id="3-1-定义方式"><a href="#3-1-定义方式" class="headerlink" title="3.1.定义方式"></a>3.1.定义方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">    String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;	<span class="comment">//default true 表示默认值为true,使用时可以不赋值。</span></span><br><span class="line">    String[] ccc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-元注解"><a href="#3-2-元注解" class="headerlink" title="3.2.元注解"></a>3.2.元注解</h2><p>元注解是修饰注解的注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Target是用来声明注解只能用在那些位置，比如：类上、方法上、成员变量上等</span><br><span class="line">@Retetion是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期</span><br></pre></td></tr></table></figure>

<h2 id="3-3-解析注解"><a href="#3-3-解析注解" class="headerlink" title="3.3.解析注解"></a>3.3.解析注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest3</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.先获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Demo.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.解析Demo类上的注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(MyTest4.class))&#123;</span><br><span class="line">            <span class="comment">//获取类上的MyTest4注解</span></span><br><span class="line">            <span class="type">MyTest4</span> <span class="variable">myTest4</span> <span class="operator">=</span> (MyTest4)c.getDeclaredAnnotation(MyTest4.class);</span><br><span class="line">            <span class="comment">//获取MyTests4注解的属性值</span></span><br><span class="line">            System.out.println(myTest4.value());</span><br><span class="line">            System.out.println(myTest4.aaa());</span><br><span class="line">            System.out.println(myTest4.bbb());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.先获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Demo.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.解析Demo类中test1方法上的注解MyTest4注解</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(m.isAnnotationPresent(MyTest4.class))&#123;</span><br><span class="line">            <span class="comment">//获取方法上的MyTest4注解</span></span><br><span class="line">            <span class="type">MyTest4</span> <span class="variable">myTest4</span> <span class="operator">=</span> (MyTest4)m.getDeclaredAnnotation(MyTest4.class);</span><br><span class="line">            <span class="comment">//获取MyTests4注解的属性值</span></span><br><span class="line">            System.out.println(myTest4.value());</span><br><span class="line">            System.out.println(myTest4.aaa());</span><br><span class="line">            System.out.println(myTest4.bbb());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h1><p>略</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/28/javase%E5%9F%BA%E7%A1%80/junit-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/" data-id="cli6t8kvq0000gw8abl8d3hrs" data-title="junit-反射-注解" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javase基础/线程池-网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/26/javase%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-05-26T12:03:07.000Z" itemprop="datePublished">2023-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/26/javase%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">线程池_网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1.线程池"></a>1.线程池</h1><h2 id="1-1-线程状态"><a href="#1-1-线程状态" class="headerlink" title="1.1.线程状态"></a>1.1.线程状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.state</span><br><span class="line">NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED</span><br></pre></td></tr></table></figure>

<h2 id="1-2-线程池创建"><a href="#1-2-线程池创建" class="headerlink" title="1.2.线程池创建"></a>1.2.线程池创建</h2><h3 id="1-2-1-默认方式"><a href="#1-2-1-默认方式" class="headerlink" title="1.2.1.默认方式"></a>1.2.1.默认方式</h3><p> 一般不用,因为这样创建的线程池最大线程数太多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span>:</span><br><span class="line">创建默认线程池,线程池中没有线程,首次执行submit()时,创建第一条线程</span><br><span class="line">submit(Runnable task):提交线程任务</span><br><span class="line">shutdown():关闭线程池</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span>:创建指定线程上限数量的线程池</span><br><span class="line">注意:nThreads指的是线程池中最大线程数量而不是初始数量</span><br><span class="line"><span class="type">int</span> nThreads:表示线程池中最大线程数量,首次创建没有提交任务时,线程池中线程数量为<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-自定义方法"><a href="#1-2-2-自定义方法" class="headerlink" title="1.2.2.自定义方法"></a>1.2.2.自定义方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(</span><br><span class="line">    int corePoolSize,//核心线程数量</span><br><span class="line">    int maximumPoolSize,//最大线程数量 = 核心线程数量 + 临时线程数量 &gt; 0</span><br><span class="line">    long keepAliveTime,//临时线程存活时间,值</span><br><span class="line">    TimeUnit unit,//单位</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列(超出最大线程数量任务排队)</span><br><span class="line">    ThreadFactory threadFactory,//默认线程工厂</span><br><span class="line">    RejectedExecutionHandler handler//任务拒绝策略:超出任务数量触发策略(任务数量&gt; 最大线程数量 + 阻塞队列长度)</span><br><span class="line">)</span><br><span class="line">根据指定参数创建线程池,后面的两个参数可以不写变成默认</span><br></pre></td></tr></table></figure>

<p>1.2.3.任务拒绝策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">问题:</span><br><span class="line">	1.任务拒绝策略触发时机</span><br><span class="line">	2.拒绝策略含义</span><br><span class="line">答案:</span><br><span class="line">	1.触发时机:</span><br><span class="line">	当任务总数量超过线程池能执行的最大任务数量时,触发拒绝策略</span><br><span class="line">线程池最大任务数量 = 最大线程数量 + 阻塞队列中任务数量</span><br><span class="line"></span><br><span class="line">	2.含义:</span><br><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常(默认)</span><br><span class="line">    注意:抛出异常之后,要合理进行处理,否则线程池将无法再继续执行任务</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy:丢弃任务,不抛异常(不推荐)</span><br><span class="line">    超出排队数量的任务直接丢弃,不抛异常</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy:抛弃队列中等待最久的任务,当前任务加入队列中</span><br><span class="line">	只要线程池没有关闭,丢弃队列中等待时间最长的任务,把新任务(没排上队的)进行添加</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy:绕过线程池直接执行线程任务</span><br><span class="line">	一般并发比较少,还不要求性能,但是不允许任务执行失败</span><br><span class="line">	如果任务量大,并发量大,此时造成阻塞,性能会受到很大影响</span><br></pre></td></tr></table></figure>

<h1 id="2-网络编程"><a href="#2-网络编程" class="headerlink" title="2.网络编程"></a>2.网络编程</h1><pre><code>三要素
- IP地址 	设备在网络中的唯一标识
- 端口 	应用程序在设备中的唯一标识
- 协议	计算机连接和通信的规则
</code></pre>
<h2 id="2-1-IP"><a href="#2-1-IP" class="headerlink" title="2.1.IP"></a>2.1.IP</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">问题:</span><br><span class="line">	1. 什么是IP?</span><br><span class="line">	2. IP有哪些分类?</span><br><span class="line">答案:</span><br><span class="line">	1.IP:设备在网络中的唯一标识</span><br><span class="line">	2.分类:</span><br><span class="line">		- IPv4:IP地址32bit(4字节)</span><br><span class="line">		使用[.分十进制表示法],每8bit为一组,转换为十进制数据,并使用[.]进行分隔</span><br><span class="line">		可以表示的IP总量 255.255.255.255</span><br><span class="line">		- IPv6:IP地址128bit(16字节)</span><br><span class="line">		使用[:分十六进制表示法],每16bit为一组,转换为十六进制数据,并使用[:]进行分隔</span><br><span class="line">注意:如果在同一个网络环境下,不同设备使用相同的IP地址会导致后接入网络设备无法连接网络</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br><span class="line">ping</span><br></pre></td></tr></table></figure>

<h2 id="2-2-端口"><a href="#2-2-端口" class="headerlink" title="2.2.端口"></a>2.2.端口</h2><pre><code>1.取值范围[0,65535]
2.普通应用程序可用范围[1024,65535]
</code></pre>
<h2 id="2-3-协议"><a href="#2-3-协议" class="headerlink" title="2.3.协议"></a>2.3.协议</h2><p>UDP协议和TCP协议</p>
<h1 id="3-UDP发送和接收"><a href="#3-UDP发送和接收" class="headerlink" title="3.UDP发送和接收"></a>3.UDP发送和接收</h1><h2 id="3-1-发送"><a href="#3-1-发送" class="headerlink" title="3.1.发送"></a>3.1.发送</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">构造方法:</span><br><span class="line">DatagramSocket()创建数据报套接字并将其绑定到本机地址上的任何可用端口				 	DatagramPacket(<span class="type">byte</span>[] buf,<span class="type">int</span> len,InetAddress add,<span class="type">int</span> port)</span><br><span class="line">	创建数据包,发送长度为len的数据包到指定主机的指定端口</span><br><span class="line">	参数解析:</span><br><span class="line">		<span class="type">byte</span>[] buf:数据的字节数组</span><br><span class="line">		<span class="type">int</span> len:数组中发送多少个数据</span><br><span class="line">		InetAddress add:接收端设备的IP地址</span><br><span class="line">		<span class="type">int</span> port:接收端的端口号</span><br><span class="line">成员方法:</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">send</span><span class="params">(DatagramPacket p)</span>发送数据报包</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>关闭数据报套接字</span><br><span class="line">	</span><br><span class="line">[操作步骤]</span><br><span class="line"><span class="number">1.</span>创建发送端的Socket对象(DatagramSocket)</span><br><span class="line"><span class="number">2.</span>创建数据，并把数据打包</span><br><span class="line"><span class="number">3.</span>调用DatagramSocket对象的方法发送数据</span><br><span class="line"><span class="number">4.</span>关闭发送端</span><br><span class="line">[UDP发送端代码实现]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendDemo</span> &#123;<span class="comment">//理解为广播电视台</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="comment">// DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">        <span class="comment">//DatagramPacket(byte[] buf, int length, InetAddress address, int port)</span></span><br><span class="line">        <span class="comment">//参数1:存储数据的字节数组 参数2:传输数据的个数 参数3:接收端IP地址 参数4:接收端端口号</span></span><br><span class="line">        <span class="comment">//构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。</span></span><br><span class="line">        <span class="type">byte</span>[] bys = <span class="string">&quot;hello,udp,我来了&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys,bys.length,InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">        <span class="comment">//void send(DatagramPacket p) 从此套接字发送数据报包</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        <span class="comment">//void close() 关闭此数据报套接字</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="3-2-接受端"><a href="#3-2-接受端" class="headerlink" title="3.2.接受端"></a>3.2.接受端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">构造方法:</span><br><span class="line">DatagramSocket(传递端口号)创建数据报套接字并将其绑定到本机地址上的任何可用端口</span><br><span class="line">注意:接收端端口号和发送端端口号保持一致,否则接收不到数据</span><br><span class="line">DatagramPacket(byte[] buf,int len)</span><br><span class="line">byte[] buf:用来接收数据的字节数组</span><br><span class="line">int len:数组多少长度用来接收数据</span><br><span class="line">成员方法</span><br><span class="line">void receive(DatagramPacket p)从此套接字接受数据报包</span><br><span class="line">注意:该方法为阻塞方法,直到接收到发送端发送的数据之后,才结束阻塞</span><br><span class="line"></span><br><span class="line">[操作步骤]</span><br><span class="line">1.创建接收端的Socket对象(DatagramSocket)</span><br><span class="line">2.创建一个数据包，用于接收数据</span><br><span class="line">3.调用DatagramSocket对象的方法接收数据</span><br><span class="line">4.解析数据包，并把数据在控制台显示</span><br><span class="line">5.关闭接收端</span><br><span class="line">[代码实现]</span><br><span class="line">public class ReceiveDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">      	//创建接收端的Socket对象(DatagramSocket)</span><br><span class="line">      	//和发送端端口号保持一致</span><br><span class="line">      	DatagramSocket ds = new DatagramSocket(10086);</span><br><span class="line"></span><br><span class="line">      	//创建一个数据包，用于接收数据</span><br><span class="line">      	byte[] bys = new byte[1024];</span><br><span class="line">      	DatagramPacket dp = new DatagramPacket(bys, bys.length);</span><br><span class="line"></span><br><span class="line">      	//调用DatagramSocket对象的方法接收数据</span><br><span class="line">      	ds.receive(dp);//阻塞</span><br><span class="line">      	//此时先运行接收端,开启阻塞</span><br><span class="line"></span><br><span class="line">      	//解析数据包，并把数据在控制台显示</span><br><span class="line">      	System.out.println(&quot;数据是：&quot; + new String(bys, 0,                                             dp.getLength()));//dp.getLength()获取接收的有效数据个数</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //关闭接收端</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-UDP三种通讯方式"><a href="#3-3-UDP三种通讯方式" class="headerlink" title="3.3.UDP三种通讯方式"></a>3.3.UDP三种通讯方式</h2><h3 id="3-3-1-单播"><a href="#3-3-1-单播" class="headerlink" title="3.3.1.单播"></a>3.3.1.单播</h3><h3 id="3-3-2-组播"><a href="#3-3-2-组播" class="headerlink" title="3.3.2.组播"></a>3.3.2.组播</h3><p>IP取值范围[224.0.0.0,239.255.255.255]<br>    用户可用IP取值范围[224.0.1.0,239.255.255.255]</p>
<h3 id="3-3-3-广播"><a href="#3-3-3-广播" class="headerlink" title="3.3.3.广播"></a>3.3.3.广播</h3><p>​	广播IP:255.255.255.255</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/26/javase%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="cli6qqj1r0002jc8ack5h3txu" data-title="线程池_网络编程" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javaweb/springboot请求响应" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/25/javaweb/springboot%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/" class="article-date">
  <time class="dt-published" datetime="2023-05-25T02:13:43.000Z" itemprop="datePublished">2023-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/25/javaweb/springboot%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/">springboot请求响应</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="1-Servlet容器"><a href="#1-Servlet容器" class="headerlink" title=".1.Servlet容器"></a>.1.Servlet容器</h2><h2 id="1-1-最古早的技术"><a href="#1-1-最古早的技术" class="headerlink" title=".1.1.最古早的技术"></a>.1.1.最古早的技术</h2><p>做javaweb开发最原始的技术 接受http请求并且相应</p>
<p>BS架构:客户端只需要浏览器,应用程序的逻辑和数据都存储在客户端</p>
<p>CS架构:客户端\服务器架构模式</p>
<p>Server是Tomcat最顶层的容器</p>
<h2 id="1-2-Tomcat"><a href="#1-2-Tomcat" class="headerlink" title=".1.2.Tomcat"></a>.1.2.Tomcat</h2><p>tomcat是作为既能和浏览器交互,又能和后端交互的代理软件.</p>
<h1 id="1-请求"><a href="#1-请求" class="headerlink" title="1.请求"></a>1.请求</h1><h2 id="1-1-Postman"><a href="#1-1-Postman" class="headerlink" title="1.1.Postman"></a>1.1.Postman</h2><p>1.1.1.介绍</p>
<p>一款网页调试,发送网页HTTP请求的插件</p>
<h2 id="1-2-接收方式"><a href="#1-2-接收方式" class="headerlink" title="1.2.接收方式"></a>1.2.接收方式</h2><ul>
<li>HttpServletRequest 接收</li>
<li>SpringBoot方式接收</li>
</ul>
<h3 id="1-2-1-简单参数"><a href="#1-2-1-简单参数" class="headerlink" title="1.2.1.简单参数"></a>1.2.1.简单参数</h3><p>直接在响应方法参数里面接收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.format.annotation.DateTimeFormat;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">quireUser1</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;queryUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">quire1</span><span class="params">(Integer age, Integer gender, <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span>LocalDateTime updateTime)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@DateTimeFormat专门治Date</p>
<h3 id="1-2-2-实体参数"><a href="#1-2-2-实体参数" class="headerlink" title="1.2.2.实体参数"></a>1.2.2.实体参数</h3><p>接收变量名字一定要对上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">quireUser2</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;queryUser2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">quire2</span><span class="params">(User2 user2)</span>&#123;</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User2</span> &#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line">    String phone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get,set,toString略过</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-套娃实体"><a href="#1-2-3-套娃实体" class="headerlink" title="1.2.3.套娃实体"></a>1.2.3.套娃实体</h3><p>就加点进行接收</p>
<p>响应方法不变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User3</span> &#123;</span><br><span class="line">    Integer id;</span><br><span class="line">    String name;</span><br><span class="line">    String phone;</span><br><span class="line">    Idcard idcard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Idcard</span> &#123;</span><br><span class="line">    String no;</span><br><span class="line">    String nation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求数据如下:</p>
<table>
<thead>
<tr>
<th>id</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>张三</td>
</tr>
<tr>
<td>phone</td>
<td>19232131231</td>
</tr>
<tr>
<td>idcard.no</td>
<td>1</td>
</tr>
<tr>
<td>idcard.nation</td>
<td>种花家</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-2-3-数组"><a href="#1-2-3-数组" class="headerlink" title="1.2.3.数组"></a>1.2.3.数组</h3><p>用数组进行接收</p>
<p>有两种请求方式:</p>
<table>
<thead>
<tr>
<th>hobby</th>
<th>swim</th>
</tr>
</thead>
<tbody><tr>
<td>hobby</td>
<td>sing</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>hobby</th>
<th>swim,sing</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-2-4-集合"><a href="#1-2-4-集合" class="headerlink" title="1.2.4.集合"></a>1.2.4.集合</h3><p>要记得在参数加上RequestParam不然不报错也传不进去值,同时:</p>
<ul>
<li>dufaultValue 在不需要输入的时候就顶上一个默认值</li>
<li>required 变量是否必须,默认为true</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> String <span class="title function_">quire43</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;123&quot;,required = true)</span>List&lt;String&gt; subjects)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK43&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//传递到对象里面的数据结构就不需要用注解了</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-5-JSON对象"><a href="#1-2-5-JSON对象" class="headerlink" title="1.2.5.JSON对象"></a>1.2.5.JSON对象</h3><p>需要用一个实体对象进行封装,属性对应写就可以,在之前使用@Requestbody修饰一下</p>
<h3 id="1-2-6-路径参数"><a href="#1-2-6-路径参数" class="headerlink" title="1.2.6.路径参数"></a>1.2.6.路径参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/queryUser6/1/18800001111</span><br><span class="line">其中1是id,18800001111是phone</span><br></pre></td></tr></table></figure>

<p>那么请求可以这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">quireUser6</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;queryUser6/&#123;id&#125;/&#123;phone&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">quire41</span><span class="params">(<span class="meta">@PathVariable</span> Integer id,<span class="meta">@PathVariable</span> String phone)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        System.out.println(<span class="string">&quot;phone = &quot;</span> + phone);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK5&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3.总结"></a>1.3.总结</h2><ol>
<li>定义方法形参,请求参数名和形参变量名一致</li>
<li>不一致用@RequestParam手动映射</li>
<li>请求参数名和实体对象的属性名一致可以自动接受封装</li>
<li>数组可以直接封装</li>
<li>集合需要@RequestParam进行绑定,实体里面的集合不需要</li>
<li>日期:@DateTimeForMat</li>
<li>JSON:@RequestBody</li>
<li>路径:@PathVariable</li>
</ol>
<h1 id="2-响应"><a href="#2-响应" class="headerlink" title="2.响应"></a>2.响应</h1><h2 id="2-1-ResponseBody"><a href="#2-1-ResponseBody" class="headerlink" title="2.1.@ResponseBody"></a>2.1.@ResponseBody</h2><p>注释在Controller方法或类前面表示把方法返回值直接相应给浏览器</p>
<p>@RestController &#x3D; @Controller + @ResponseBody </p>
<h2 id="2-2-统一响应结果"><a href="#2-2-统一响应结果" class="headerlink" title="2.2.统一响应结果"></a>2.2.统一响应结果</h2><p>统一的返回结果使用类来描述，在这个结果中包含：</p>
<ul>
<li>响应状态码：当前请求是成功，还是失败</li>
<li>状态码信息：给页面的提示信息</li>
<li>返回的数据：给前端响应的数据（字符串、对象、集合）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;<span class="comment">//响应码，1 代表成功; 0 代表失败</span></span><br><span class="line">    <span class="keyword">private</span> String msg;  <span class="comment">//响应码 描述字符串</span></span><br><span class="line">    <span class="keyword">private</span> Object data; <span class="comment">//返回的数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-分层解耦"><a href="#3-分层解耦" class="headerlink" title="3.分层解耦"></a>3.分层解耦</h1><p> 在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。</p>
<h2 id="3-1-分层"><a href="#3-1-分层" class="headerlink" title="3.1.分层"></a>3.1.分层</h2><ul>
<li>Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。</li>
<li>Service：业务逻辑层。处理具体的业务逻辑。</li>
<li>Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。</li>
</ul>
<h2 id="3-2-代码拆分"><a href="#3-2-代码拆分" class="headerlink" title="3.2.代码拆分"></a>3.2.代码拆分</h2><ul>
<li>控制层包名：xxxx.controller</li>
<li>业务逻辑层包名：xxxx.service</li>
<li>数据访问层包名：xxxx.dao</li>
</ul>
<p>包内:写一个包名的接口方便调用管理,写impl包,包里放实现类进行详细的功能实现类</p>
<ol>
<li>复用性强</li>
<li>便于维护</li>
<li>利用扩展</li>
</ol>
<h2 id="3-3-耦合问题"><a href="#3-3-耦合问题" class="headerlink" title="3.3.耦合问题"></a>3.3.耦合问题</h2><ul>
<li>内聚：软件中各个功能模块内部的功能联系。</li>
<li>耦合：衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。</li>
</ul>
<p><strong>软件设计原则：高内聚低耦合</strong></p>
<p>解耦合思路:IOC + DI</p>
<h1 id="4-IOC-x2F-DI"><a href="#4-IOC-x2F-DI" class="headerlink" title="4.IOC&#x2F;DI"></a>4.IOC&#x2F;DI</h1><p>IOC控制反转和DI依赖注入</p>
<h2 id="4-1-IOC"><a href="#4-1-IOC" class="headerlink" title="4.1.IOC"></a>4.1.IOC</h2><p>本质是把变量的管理托管给spring,由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。</p>
<p>某个对象交给IOC容器管理，需要在类上添加一个注解：@Component </p>
<p>而Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解：</p>
<ul>
<li>@Controller    （标注在控制层类上）</li>
<li>@Service          （标注在业务层类上）</li>
<li>@Repository    （标注在数据访问层类上）</li>
</ul>
<h2 id="4-2-组件扫描"><a href="#4-2-组件扫描" class="headerlink" title="4.2.组件扫描"></a>4.2.组件扫描</h2><p>使用四大注解声明的bean，要想生效，还需要被组件扫描注解@ComponentScan扫描</p>
<p>@ComponentScan包含在@SpringBootApplication中</p>
<p>@SpringBootApplication在引导类里面</p>
<h2 id="4-3-DI"><a href="#4-3-DI" class="headerlink" title="4.3.DI"></a>4.3.DI</h2><p>依赖注入，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。</p>
<p>@Autowired注解，默认是按照<strong>类型</strong>进行自动装配的</p>
<ul>
<li>@Primary</li>
<li>@Qualifier</li>
<li>@Resource</li>
</ul>
<p>Primary 制定特定类型首要bean对象</p>
<p>@Qualifier,@Resource 用类型找bean对象</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/25/javaweb/springboot%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/" data-id="cli6qqj1s0004jc8af5nrfjxv" data-title="springboot请求响应" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javase基础/线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/24/javase%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-05-24T07:20:28.000Z" itemprop="datePublished">2023-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/24/javase%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B/">多线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h1><h2 id="1-1-一些概念"><a href="#1-1-一些概念" class="headerlink" title="1.1.一些概念"></a>1.1.一些概念</h2><table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td>正在运行的软件</td>
</tr>
<tr>
<td>线程</td>
<td>是一条执行路径简单理解:线程是正在运行的软件中的某个独立功能</td>
</tr>
<tr>
<td>并发</td>
<td>在同一时刻，有多个指令在单个CPU上[交替]执行</td>
</tr>
<tr>
<td>并行</td>
<td>在同一时刻，有多个指令在多个CPU上[同时]执行</td>
</tr>
<tr>
<td>多线程</td>
<td>是指从软件或者硬件上实现多个线程[并发]执行的技术</td>
</tr>
</tbody></table>
<h2 id="1-2-线程创建方式"><a href="#1-2-线程创建方式" class="headerlink" title="1.2.线程创建方式"></a>1.2.线程创建方式</h2><p>有三种类型</p>
<ol>
<li>使用类继承Thread,Override run方法,使用对象.start()进行启动</li>
<li>使用类实现 Runnable 接口,重写run方法</li>
<li>使用类实现 Callable 接口,重写call方法</li>
</ol>
<p>此处可以用匿名内部类进行2类型的实现</p>
<p>Callable的优点在于他可以有返回值,使用get就可以拿到,JDK5开始提供</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>继承Thread类</td>
<td>代码简单，可以直接使用Thread类中的方法</td>
<td>扩展性差,不能再继承其他的类</td>
</tr>
<tr>
<td>实现Runnable、 Callable接口</td>
<td>扩展性强，不影响继承关系使用</td>
<td>代码复杂，不能直接使Thread类中的方法,需要进行转换</td>
</tr>
</tbody></table>
<p>想要有返回值或者处理异常,使用Callable</p>
<p>想要作为参数传递,一般使用Runnable</p>
<h1 id="2-Thread类"><a href="#2-Thread类" class="headerlink" title="2.Thread类"></a>2.Thread类</h1><h2 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1.方法"></a>2.1.方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getName</td>
<td></td>
</tr>
<tr>
<td>setName</td>
<td></td>
</tr>
<tr>
<td>public static Thread currentThread()</td>
<td>返回对当前正在执行的线程对象的引用</td>
</tr>
<tr>
<td>sleep()</td>
<td></td>
</tr>
<tr>
<td>setPriority()</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-1-1-线程优先级"><a href="#2-1-1-线程优先级" class="headerlink" title="2.1.1.线程优先级"></a>2.1.1.线程优先级</h3><p>增大被CPU选中进行执行的概率</p>
<h3 id="2-1-2-守护线程"><a href="#2-1-2-守护线程" class="headerlink" title="2.1.2.守护线程"></a>2.1.2.守护线程</h3><p>主线程结束,它也结束</p>
<h1 id="3-线程安全问题"><a href="#3-线程安全问题" class="headerlink" title="3.线程安全问题"></a>3.线程安全问题</h1><h2 id="3-1-产生原因"><a href="#3-1-产生原因" class="headerlink" title="3.1.产生原因"></a>3.1.产生原因</h2><p>线程的抢占式调度方式导致</p>
<p>cpu动态为线程分配资源,任意一条线程在执行run方法任务的过程中,都有可能被其他线程抢夺资源</p>
<h2 id="3-2-解决方法-同步代码块"><a href="#3-2-解决方法-同步代码块" class="headerlink" title="3.2.解决方法:同步代码块"></a>3.2.解决方法:同步代码块</h2><h3 id="3-2-1-同步代码块"><a href="#3-2-1-同步代码块" class="headerlink" title="3.2.1.同步代码块"></a>3.2.1.同步代码块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(任意对象) &#123;</span><br><span class="line">	多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//所有的Thread对象共享同一把锁</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> Object.class;</span><br><span class="line">Object.class是在类创建时生成的一个类拥有唯一的</span><br><span class="line"></span><br><span class="line">区别在于创建的对象继承Thread还是实现接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">好处和弊端</span><br><span class="line">	好处：解决多线程操作共享数据的安全问题,保证同一时刻只有一条线程能够操作共享数据</span><br><span class="line">	弊端：当线程数量较多时，每个线程都要去判断同步的锁，耗费资源同时降低程序的运行效率</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-同步代码块锁对象"><a href="#3-2-2-同步代码块锁对象" class="headerlink" title="3.2.2.同步代码块锁对象"></a>3.2.2.同步代码块锁对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">问题:</span><br><span class="line">	如何保证锁对象唯一</span><br><span class="line">答案:</span><br><span class="line">	<span class="number">1.</span>继承Thread类</span><br><span class="line">	使用<span class="keyword">static</span> <span class="keyword">final</span>修饰锁对象</span><br><span class="line">	或者使用当前类的字节码文件对象 类名.class</span><br><span class="line">        <span class="comment">//创建当前类的对象,只会使用同一份类的字节码文件</span></span><br><span class="line">        <span class="comment">//字节码文件对象也是同一个 类名.class -- 获取当前创建对象的类的字节码文件对象</span></span><br><span class="line">	<span class="number">2.</span>实现Runnable和Callable接口</span><br><span class="line">	作为参数传递,只需要创建一个实现类</span><br><span class="line">	内部定义成员变量锁对象也只会存在一份</span><br><span class="line">	不需要修改</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	或者使用<span class="built_in">this</span><span class="comment">//当前run() call()参数方法的所在的类对象</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-同步方法"><a href="#3-2-3-同步方法" class="headerlink" title="3.2.3.同步方法"></a>3.2.3.同步方法</h3><p>&#x2F;&#x2F;多线程情况下,选择线程安全的容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同步代码块可以锁住指定代码,可以指定锁对象</span><br><span class="line">同步方法只能锁住方法中所有代码,不能指定锁对象</span><br><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; &#125;</span><br><span class="line">同步方法的锁是 类.class</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-lock锁"><a href="#3-2-4-lock锁" class="headerlink" title="3.2.4.lock锁"></a>3.2.4.lock锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">        ReentrantLock的对象.lock();<span class="comment">//加锁</span></span><br><span class="line">        操作共享数据的代码;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(异常类型 变量名)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        ReentrantLock的对象.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-5-死锁"><a href="#3-2-5-死锁" class="headerlink" title="3.2.5.死锁"></a>3.2.5.死锁</h3><ol>
<li>互斥条件</li>
<li>请求保持</li>
<li>不剥夺</li>
<li>循环等待</li>
</ol>
<h1 id="4-生产者消费者模型"><a href="#4-生产者消费者模型" class="headerlink" title="4.生产者消费者模型"></a>4.生产者消费者模型</h1><h2 id="4-1-等待唤醒机制"><a href="#4-1-等待唤醒机制" class="headerlink" title="4.1.等待唤醒机制"></a>4.1.等待唤醒机制</h2><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>当前线程等待，直到另一个线程调用该对象的 notify()或 notify All()方法</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody></table>
<p>4.2.示例代码:(大便例子,这个flag的意义就很奇怪)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">代码实现:</span><br><span class="line">[Desk.java 容器(桌子类)]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储数据的容器:</span></span><br><span class="line"><span class="comment">	1, 记录数据总数量</span></span><br><span class="line"><span class="comment">	2, 有数据,记录为true</span></span><br><span class="line"><span class="comment">	3, 没有数据,记录为false</span></span><br><span class="line"><span class="comment">	4, 消费数据后,总数量-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//定义标记</span></span><br><span class="line">    <span class="comment">//true:桌子上有汉堡包的,此时允许吃货执行</span></span><br><span class="line">    <span class="comment">//false:桌子上没有汉堡包,此时允许厨师执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//汉堡包的总数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line">[Cooker.java 生产者(厨师类)]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cooker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生产者：</span></span><br><span class="line"><span class="comment">    1，判断容器中是否有数据</span></span><br><span class="line"><span class="comment">    2，如果有,线程等待，如果没有,生产数据</span></span><br><span class="line"><span class="comment">    3，修改容器状态</span></span><br><span class="line"><span class="comment">    3，唤醒等待的消费者消费数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Desk.lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Desk.count == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Desk.flag)&#123;<span class="comment">//表示有数据,等消费者消费</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Desk.lock.wait();<span class="comment">//生产者等待</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有数据</span></span><br><span class="line">                    <span class="comment">//生产数据</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;厨师正在生产汉堡包&quot;</span>);</span><br><span class="line">                        Desk.flag = <span class="literal">true</span>;<span class="comment">//改变当前数据状态为true</span></span><br><span class="line">                        Desk.lock.notifyAll();<span class="comment">//唤醒等待的消费者消费</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[Foodie.java 消费者(吃货类)]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">消费者：</span></span><br><span class="line"><span class="comment">    1，判断容器中有没有数据</span></span><br><span class="line"><span class="comment">    2，如果没有,线程等待</span></span><br><span class="line"><span class="comment">    3，如果有,消费数据</span></span><br><span class="line"><span class="comment">    4，消费数据之后，修改容器状态,唤醒等待的生产者生产数据,容器中数据的总数量-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Desk.lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Desk.count == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Desk.flag)&#123;        <span class="comment">//有数据,消费数据</span></span><br><span class="line">                </span><br><span class="line">                        System.out.println(<span class="string">&quot;吃货在吃汉堡包&quot;</span>);</span><br><span class="line">                        Desk.flag = <span class="literal">false</span>;<span class="comment">//消费数据,改变数据状态为false</span></span><br><span class="line">                        Desk.lock.notifyAll();<span class="comment">//唤醒等待的生产者生产</span></span><br><span class="line">                        Desk.count--;<span class="comment">//数据总数量-1</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//没有数据,等待</span></span><br><span class="line">                        <span class="comment">//使用锁对象调用等待和唤醒的方法.</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Desk.lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[Demo.java 测试类]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>();</span><br><span class="line">        <span class="type">Cooker</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cooker</span>();</span><br><span class="line"></span><br><span class="line">        f.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/24/javase%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B/" data-id="cli6qqj1r0003jc8agujca7vk" data-title="多线程" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javaweb/SpringBoot" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/24/javaweb/SpringBoot/" class="article-date">
  <time class="dt-published" datetime="2023-05-24T06:22:06.000Z" itemprop="datePublished">2023-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/24/javaweb/SpringBoot/">SpringBoot</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-SpringBootWeb入门"><a href="#1-SpringBootWeb入门" class="headerlink" title="1.SpringBootWeb入门"></a>1.SpringBootWeb入门</h1><p>Spring家族旗下这么多的技术，最基础、最核心的是 SpringFramework。其他的spring家族的技术，都是基于SpringFramework的，SpringFramework中提供很多实用功能，如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。</p>
<p>通过springboot就可以快速的帮我们构建应用程序，所以springboot呢，最大的特点有两个 ：</p>
<ul>
<li>简化配置</li>
<li>快速开发</li>
</ul>
<p><strong>Spring Boot 可以帮助我们非常快速的构建应用程序、简化开发、提高效率 。</strong></p>
<h2 id="1-1-开发例子"><a href="#1-1-开发例子" class="headerlink" title="1.1.开发例子"></a>1.1.开发例子</h2><h3 id="1-1-1-需求"><a href="#1-1-1-需求" class="headerlink" title="1.1.1.需求"></a>1.1.1.需求</h3><p>需求：基于SpringBoot的方式开发一个web应用，浏览器发起请求&#x2F;hello后，给浏览器返回字符串 “Hello World ~”。</p>
<h3 id="1-1-2-创建SpringBoot工程-需要联网"><a href="#1-1-2-创建SpringBoot工程-需要联网" class="headerlink" title="1.1.2.创建SpringBoot工程(需要联网)"></a>1.1.2.创建SpringBoot工程(需要联网)</h3><p> 需要注意的几个词条:</p>
<blockquote>
<p>Group:写组织名字</p>
<p>SpringBoot版本选择2.7.6</p>
</blockquote>
<p>创建之后会持续下载一段时间的下载</p>
<h3 id="1-2-3-定义请求处理类"><a href="#1-2-3-定义请求处理类" class="headerlink" title="1.2.3.定义请求处理类"></a>1.2.3.定义请求处理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@RestController 交给spring框架</span></span><br><span class="line"><span class="comment">//@controller 返回数据给浏览器</span></span><br><span class="line"><span class="comment">//@ResponseBody 交给spring框架并且返回数据给浏览器</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World ~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-运行测试"><a href="#1-2-4-运行测试" class="headerlink" title="1.2.4.运行测试"></a>1.2.4.运行测试</h3><ol>
<li>运行SpringBoot自动生成的引导类</li>
<li>打开浏览器 输入<a target="_blank" rel="noopener" href="http://localhost:8080/hello">http://localhost:8080/hello</a></li>
</ol>
<h2 id="1-2-Web分析"><a href="#1-2-Web分析" class="headerlink" title="1.2.Web分析"></a>1.2.Web分析</h2><h3 id="1-2-1-浏览器"><a href="#1-2-1-浏览器" class="headerlink" title="1.2.1.浏览器"></a>1.2.1.浏览器</h3><ul>
<li>输入网址：<code>http://192.168.100.11:8080/hello</code></li>
<li>通过IP地址192.168.100.11定位到网络上的一台计算机</li>
</ul>
<blockquote>
<p>我们之前在浏览器中输入的localhost，就是127.0.0.1（本机）</p>
</blockquote>
<ul>
<li>通过端口号8080找到计算机上运行的程序</li>
</ul>
<blockquote>
<p><code>localhost:8080</code>  , 意思是在本地计算机中找到正在运行的8080端口的程序</p>
</blockquote>
<ul>
<li>&#x2F;hello是请求资源位置</li>
<li>资源：对计算机而言资源就是数据</li>
<li>web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据）</li>
</ul>
<blockquote>
<p>localhost:8080&#x2F;hello&#96; ，意思是向本地计算机中的8080端口程序，获取资源位置是&#x2F;hello的数据</p>
<p>8080端口程序，在服务器找&#x2F;hello位置的资源数据，发给浏览器</p>
</blockquote>
<h3 id="1-2-2-服务器："><a href="#1-2-2-服务器：" class="headerlink" title="1.2.2.服务器："></a>1.2.2.服务器：</h3><p>(可以理解为ServerSocket）</p>
<ul>
<li>接收到浏览器发送的信息（如：&#x2F;hello）</li>
<li>在服务器上找到&#x2F;hello的资源</li>
<li>把资源发送给浏览器</li>
</ul>
<h1 id="2-HTTP协议"><a href="#2-HTTP协议" class="headerlink" title="2.HTTP协议"></a>2.HTTP协议</h1><h2 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1.基本介绍"></a>2.1.基本介绍</h2><p>HTTP：Hyper Text Transfer Protocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。</p>
<h2 id="2-2-特点"><a href="#2-2-特点" class="headerlink" title="2.2.特点"></a>2.2.特点</h2><ul>
<li>**基于TCP协议: **   面向连接，安全</li>
<li><strong>基于请求-响应模型:</strong>   一次请求对应一次响应（先请求后响应）</li>
<li><strong>HTTP协议是无状态协议:</strong>  对于数据没有记忆能力。每次请求-响应都是独立的</li>
</ul>
<h2 id="2-3-请求协议和响应协议"><a href="#2-3-请求协议和响应协议" class="headerlink" title="2.3.请求协议和响应协议"></a>2.3.请求协议和响应协议</h2><h3 id="2-3-1-请求协议"><a href="#2-3-1-请求协议" class="headerlink" title="2.3.1.请求协议"></a>2.3.1.请求协议</h3><ul>
<li>请求行:请求方式+资源路径+协议&#x2F;版本</li>
</ul>
<p>请求方式主要有POST和GET</p>
<ul>
<li><p>请求头: key:value </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Host: 表示请求的主机名</span><br><span class="line"></span><br><span class="line">User-Agent: 浏览器版本。 例如：Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79 ，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko</span><br><span class="line"></span><br><span class="line">Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；</span><br><span class="line"></span><br><span class="line">Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</span><br><span class="line"></span><br><span class="line">Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</span><br><span class="line"></span><br><span class="line">Content-Type：请求主体的数据类型</span><br><span class="line"></span><br><span class="line">Content-Length：数据主体的大小（单位：字节）</span><br></pre></td></tr></table></figure>


</li>
<li><p>请求体: 存储请求参数</p>
<ul>
<li>GET请求的请求参数在请求行中，故不需要设置请求体</li>
</ul>
</li>
</ul>
<h4 id="GET请求和POST请求的区别："><a href="#GET请求和POST请求的区别：" class="headerlink" title="GET请求和POST请求的区别："></a>GET请求和POST请求的区别：</h4><table>
<thead>
<tr>
<th>区别方式</th>
<th>GET请求</th>
<th>POST请求</th>
</tr>
</thead>
<tbody><tr>
<td>请求参数</td>
<td>请求参数在请求行中。<br/>例：&#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1</td>
<td>请求参数在请求体中</td>
</tr>
<tr>
<td>请求参数长度</td>
<td>请求参数长度有限制(浏览器不同限制也不同)</td>
<td>请求参数长度没有限制</td>
</tr>
<tr>
<td>安全性</td>
<td>安全性低。原因：请求参数暴露在浏览器地址栏中。</td>
<td>安全性相对高</td>
</tr>
</tbody></table>
<h3 id="2-3-2-响应协议"><a href="#2-3-2-响应协议" class="headerlink" title="2.3.2.响应协议"></a>2.3.2.响应协议</h3><ul>
<li>相应行:协议&#x2F;版本 + 响应状态码 + 状态码描述</li>
</ul>
<p>状态码主要有三个:200 ok 404 Not Found 500 服务器错误</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><table>
<thead>
<tr>
<th>状态码分类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td><strong>响应中</strong> — 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略</td>
</tr>
<tr>
<td>2xx</td>
<td><strong>成功</strong> — 表示请求已经被成功接收，处理已完成</td>
</tr>
<tr>
<td>3xx</td>
<td><strong>重定向</strong> — 重定向到其它地方，让客户端再发起一个请求以完成整个处理</td>
</tr>
<tr>
<td>4xx</td>
<td><strong>客户端错误</strong> — 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td>
</tr>
<tr>
<td>5xx</td>
<td><strong>服务器端错误</strong> — 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td>
</tr>
</tbody></table>
<ul>
<li><p>响应头: key:value</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg ；</span><br><span class="line"></span><br><span class="line">Content-Length：表示该响应内容的长度（字节数）；</span><br><span class="line"></span><br><span class="line">Content-Encoding：表示该响应压缩算法，例如gzip ；</span><br><span class="line"></span><br><span class="line">Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 ;</span><br><span class="line"></span><br><span class="line">Set-Cookie: 告诉浏览器为当前页面所在的域设置cookie ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应体:</p>
</li>
</ul>
<p>响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束）</p>
<h2 id="2-4-HTTP-协议解析"><a href="#2-4-HTTP-协议解析" class="headerlink" title="2.4.HTTP-协议解析"></a>2.4.HTTP-协议解析</h2><p>要写一大堆,可以用Tomcat代劳</p>
<h1 id="3-Tomcat"><a href="#3-Tomcat" class="headerlink" title="3.Tomcat"></a>3.Tomcat</h1><p>需要用到浏览器就可以使用Tomcat进行操作</p>
<p>作用:解析请求,把数据响应到浏览器</p>
<h2 id="3-1-服务器"><a href="#3-1-服务器" class="headerlink" title="3.1.服务器"></a>3.1.服务器</h2><ul>
<li><p>服务器硬件</p>
</li>
<li><p>服务器软件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 服务器软件本质是一个运行在服务器设备上的应用程序</span><br><span class="line">- 能够接收客户端请求，并根据请求给客户端响应数据</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-2-Web服务器"><a href="#3-2-Web服务器" class="headerlink" title="3.2.Web服务器"></a>3.2.Web服务器</h2><p>Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷。主要功能是”提供网上信息浏览服务”。</p>
<p>Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p>
<h2 id="3-3-使用"><a href="#3-3-使用" class="headerlink" title="3.3.使用"></a>3.3.使用</h2><ol>
<li>解压到目录</li>
<li>把写好的网页放在webapps里面然后点在安装目录的start.bat</li>
<li>在浏览器中访问相对应的网址</li>
</ol>
<p>端口在&#x2F;conf&#x2F;settings.xml里面有一个server的属性可以设置</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/24/javaweb/SpringBoot/" data-id="cli1cynuj00008s8abape0lyi" data-title="SpringBoot" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javase基础/特殊文件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/23/javase%E5%9F%BA%E7%A1%80/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2023-05-23T00:47:10.000Z" itemprop="datePublished">2023-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/23/javase%E5%9F%BA%E7%A1%80/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/">特殊文件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-属性文件"><a href="#1-属性文件" class="headerlink" title="1.属性文件"></a>1.属性文件</h1><h2 id="1-1-意义"><a href="#1-1-意义" class="headerlink" title="1.1.意义"></a>1.1.意义</h2><p>更方便于数据的存取</p>
<ul>
<li>后缀为.properties的文件，称之为属性文件，它可以很方便的存储一些类似于键值对的数据。经常当做软件的配置文件使用。</li>
<li>而xml文件能够表示更加复杂的数据关系，比如要表示多个用户的用户名、密码、家乡、性别等。在后面，也经常当做软件的配置文件使用。</li>
</ul>
<h2 id="1-2-属性文件特点"><a href="#1-2-属性文件特点" class="headerlink" title="1.2.属性文件特点"></a>1.2.属性文件特点</h2><ol>
<li>属性文件后缀以<code>.properties</code>结尾</li>
<li>属性文件里面的每一行都是一个键值对，键和值中间用&#x3D;隔开。比如: <code>admin=123456</code> </li>
<li><code>#</code>表示这样是注释信息，是用来解释这一行配置是什么意思。</li>
<li>每一行末尾不要习惯性加分号，以及空格等字符；不然会把分号，空格会当做值的一部分。</li>
<li>键不能重复，值可以重复</li>
</ol>
<h2 id="1-3-读取方法"><a href="#1-3-读取方法" class="headerlink" title="1.3.读取方法"></a>1.3.读取方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Properties()</td>
<td>构造</td>
</tr>
<tr>
<td>public void load(InputStream is)</td>
<td>读取键值对</td>
</tr>
<tr>
<td>public void load(Reader reader)</td>
<td>读取键值对</td>
</tr>
<tr>
<td>public String getProperty</td>
<td>类似get</td>
</tr>
<tr>
<td>public Set<String> stringPropertyNames()</td>
<td>类似keySet</td>
</tr>
</tbody></table>
<h2 id="1-4-写入方法"><a href="#1-4-写入方法" class="headerlink" title="1.4.写入方法"></a>1.4.写入方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明方法</th>
</tr>
</thead>
<tbody><tr>
<td>public Object setProperty(String key, String value)</td>
<td>保存键值对数据</td>
</tr>
<tr>
<td>public void store(OutputStream os, String comments)</td>
<td>字节流</td>
</tr>
<tr>
<td>public void store(Writer w, String comments)</td>
<td>字符流</td>
</tr>
</tbody></table>
<h1 id="2-XML文件"><a href="#2-XML文件" class="headerlink" title="2.XML文件"></a>2.XML文件</h1><h2 id="2-1-XML特点-x2F-语法"><a href="#2-1-XML特点-x2F-语法" class="headerlink" title="2.1.XML特点&#x2F;语法"></a>2.1.XML特点&#x2F;语法</h2><blockquote>
<ul>
<li>XML中的<code>&lt;标签名&gt;</code> 称为一个标签或者一个元素，一般是成对出现的。</li>
<li>XML中的标签名可以自己定义（可扩展），但是必须要正确的嵌套</li>
<li>XML中只能有一个根标签。</li>
<li>XML标准中可以有属性</li>
<li>XML必须第一行有一个文档声明，格式是固定的<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></li>
<li>XML文件必须是以.xml为后缀结尾</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注释：以上抬头声明必须放在第一行，必须有 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  根标签只能有一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一个用户&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张无忌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>minmin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">people</span>&gt;</span>很多人<span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>敏敏<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>wuji<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span>  表示 &lt;</span><br><span class="line"><span class="symbol">&amp;gt;</span>  表示 &gt;</span><br><span class="line"><span class="symbol">&amp;amp;</span> 表示 &amp;</span><br><span class="line"><span class="symbol">&amp;apos;</span> 表示 &#x27;</span><br><span class="line"><span class="symbol">&amp;quot;</span> 表示 &quot;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span> 3 <span class="symbol">&amp;lt;</span> 2 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> 5 <span class="symbol">&amp;gt;</span> 4 <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">data1</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">   		3 &lt; 2 &amp;&amp; 5 &gt; 4</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">data1</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-2-XML解析"><a href="#2-2-XML解析" class="headerlink" title="2.2.XML解析"></a>2.2.XML解析</h2><h3 id="2-2-1-解析步骤1"><a href="#2-2-1-解析步骤1" class="headerlink" title="2.2.1.解析步骤1"></a>2.2.1.解析步骤1</h3><p>DOM4J:Dowument对象表示真个XML文档、Element对象表示标签（元素）、Attribute对象表示属性、标签中的内容就是文本</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SAXReader()</td>
<td>构造</td>
</tr>
<tr>
<td>public Document read(String url)</td>
<td>XML读成Document对象</td>
</tr>
<tr>
<td>public Document read(InputStrream is)</td>
<td>字节流读取</td>
</tr>
<tr>
<td>Element getRootElement()</td>
<td>获得根元素对象</td>
</tr>
</tbody></table>
<p>从外层往里层解析</p>
<h3 id="2-2-2-解析步骤2"><a href="#2-2-2-解析步骤2" class="headerlink" title="2.2.2.解析步骤2"></a>2.2.2.解析步骤2</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String getName()</td>
<td>得到元素名字</td>
</tr>
<tr>
<td>public List<Element> elements()</td>
<td>获得所有子元素</td>
</tr>
<tr>
<td>public List<Element> elements(String name)</td>
<td>得到当前元素下指定子元素返回集合</td>
</tr>
<tr>
<td>public Element elment(String name)</td>
<td>得到指定名字的子元素</td>
</tr>
<tr>
<td>public String attributeValue(String name)</td>
<td>属性名得到属性值</td>
</tr>
<tr>
<td>public String elementText(子元素名)</td>
<td>得到特定名称的子元素文本</td>
</tr>
<tr>
<td>public String getText()</td>
<td>得到文本</td>
</tr>
</tbody></table>
<h3 id="2-2-3-XML文件写入"><a href="#2-2-3-XML文件写入" class="headerlink" title="2.2.3.XML文件写入"></a>2.2.3.XML文件写入</h3><p>使用StringBuilder按照标签的格式拼接，然后再使用BufferedWriter写到XML文件中去就可以了。</p>
<h1 id="3-日志技术"><a href="#3-日志技术" class="headerlink" title="3.日志技术"></a>3.日志技术</h1><blockquote>
<p>日志可以将系统执行的信息，方便的记录到指定位置，可以是控制台、可以是文件、可以是数据库中。</p>
<p>日志可以随时以开关的形式控制启停，无需侵入到源代码中去修改。</p>
</blockquote>
<h2 id="3-1-Logback"><a href="#3-1-Logback" class="headerlink" title="3.1.Logback"></a>3.1.Logback</h2><h3 id="3-1-1-使用步骤"><a href="#3-1-1-使用步骤" class="headerlink" title="3.1.1.使用步骤"></a>3.1.1.使用步骤</h3><ol>
<li>在资料中找到<code>slftj-api.jar、logback-core.jar、logback-classes.jar</code> 这三个jar包，复制一下</li>
<li>在当前模块下面新建一个lib文件夹，把刚刚复制的三个jar包都粘贴到此处</li>
<li>从资料中找到<code>logback.xml</code>配置文件，将此文件复制粘贴到src目录下（必须是src目录）</li>
<li>然后就可以开始写代码了，在代码中创建一个日志记录日对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBackTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Logger日志对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;LogBackTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//while (true) &#123;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法开始执行~~~&quot;</span>);</span><br><span class="line">                chu(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法执行成功~~~&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;chu法方法执行失败了，出现了bug~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数a:&quot;</span> + a);</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数b:&quot;</span> + b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;结果是：&quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-日志配置文件"><a href="#3-1-2-日志配置文件" class="headerlink" title="3.1.2.日志配置文件"></a>3.1.2.日志配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 可以配置日志输出的位置是文件、还是控制台</span><br><span class="line">2. 可以配置日志输出的格式</span><br><span class="line">3. 还可以配置日志关闭和开启、以及哪些日志输出哪些日志不输出。</span><br><span class="line">4. 可以配置日志级别</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/23/javase%E5%9F%BA%E7%A1%80/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/" data-id="clhzvhyw9000dro8a31vs2f9p" data-title="特殊文件" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javaweb/maven" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/23/javaweb/maven/" class="article-date">
  <time class="dt-published" datetime="2023-05-23T00:36:33.000Z" itemprop="datePublished">2023-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/23/javaweb/maven/">maven</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th>前端</th>
<th>后端</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nodejs</td>
<td>cdk</td>
<td>基础</td>
</tr>
<tr>
<td>vue</td>
<td>SpringBoot</td>
<td>框架</td>
</tr>
<tr>
<td>nginx</td>
<td>tomcat</td>
<td>部署</td>
</tr>
<tr>
<td>npm</td>
<td>maven</td>
<td>下载依赖,构建框架,编译打包</td>
</tr>
</tbody></table>
<h1 id="1-Maven"><a href="#1-Maven" class="headerlink" title="1.Maven"></a>1.Maven</h1><p>管理和构建项目的工具,基于项目对象模型(POM)的概念,通过一小段描述信息来管理项目的创建.</p>
<h2 id="1-1-功能"><a href="#1-1-功能" class="headerlink" title="1.1.功能"></a>1.1.功能</h2><ul>
<li>生成标准工程模板,(在不同的编写平台上产生相同的项目目录结构)</li>
<li>下载依赖,(在xml里面)</li>
<li>清理编译测试打包发布</li>
</ul>
<h2 id="1-2-项目目录说明"><a href="#1-2-项目目录说明" class="headerlink" title="1.2.项目目录说明"></a>1.2.项目目录说明</h2><blockquote>
<p>目录说明： </p>
<ul>
<li>src&#x2F;main&#x2F;java: java源代码目录</li>
<li>src&#x2F;main&#x2F;resources:  配置文件信息</li>
<li>src&#x2F;test&#x2F;java: 测试代码</li>
<li>src&#x2F;test&#x2F;resources: 测试配置文件信息</li>
</ul>
</blockquote>
<h2 id="1-3-Maven模型"><a href="#1-3-Maven模型" class="headerlink" title="1.3.Maven模型"></a>1.3.Maven模型</h2><ul>
<li>项目对象模型 (Project Object Model)</li>
<li>依赖管理模型(Dependency)</li>
<li>构建生命周期&#x2F;阶段(Build lifecycle &amp; phases)</li>
</ul>
<p>1.构建生命周期&#x2F;阶段</p>
<p>用插件来进行管理</p>
<p>2.项目对象模型</p>
<p>将项目抽象成一个对象模型，有自己专属的坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt; &lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt; &lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt; &lt;/version&gt;</span><br></pre></td></tr></table></figure>

<p>3.依赖管理模型</p>
<h2 id="1-4-Maven仓库"><a href="#1-4-Maven仓库" class="headerlink" title="1.4.Maven仓库"></a>1.4.Maven仓库</h2><p>Maven仓库分为：</p>
<ul>
<li>本地仓库：自己计算机上的一个目录(用来存储jar包)</li>
<li>中央仓库：由Maven团队维护的全球唯一的。仓库地址：<a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li>
<li>远程仓库(私服)：一般由公司团队搭建的私有仓库</li>
</ul>
<h2 id="1-5-Maven安装"><a href="#1-5-Maven安装" class="headerlink" title="1.5.Maven安装"></a>1.5.Maven安装</h2><h3 id="1-5-1-安装步骤"><a href="#1-5-1-安装步骤" class="headerlink" title="1.5.1.安装步骤:"></a>1.5.1.安装步骤:</h3><ol>
<li>解压安装</li>
<li>配置仓库</li>
<li>配置Maven环境变量<br>MAVEN_PATH<br>Path</li>
<li>mvn -v</li>
</ol>
<h3 id="1-5-2-maven安装目录结构"><a href="#1-5-2-maven安装目录结构" class="headerlink" title="1.5.2.maven安装目录结构"></a>1.5.2.maven安装目录结构</h3><p> bin:存放可执行命令</p>
<p>conf:存放Maven的配置文件. 后期需要修改settings.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">设置淘宝私服镜像地址</span><br><span class="line">&lt;mirror&gt;  </span><br><span class="line">	  &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">	  &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">	  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">	  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          </span><br><span class="line">  &lt;/mirror&gt;</span><br><span class="line">  </span><br><span class="line">配置本地仓库</span><br><span class="line">&lt;localRepository&gt;E:\java\apache-maven-3.6.1-bin\apache-maven-3.6.1\mvn_repo&lt;/localRepository&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-5-3-IDEA集成"><a href="#1-5-3-IDEA集成" class="headerlink" title="1.5.3.IDEA集成"></a>1.5.3.IDEA集成</h3><p>File  &#x3D;&gt;  Settings  &#x3D;&gt;  Build,Execution,Deployment  &#x3D;&gt;  Build Tools  &#x3D;&gt;  Maven</p>
<p>手动设置Maven安装目录,配置文件</p>
<p>File  &#x3D;&gt;  Settings  &#x3D;&gt;  Build,Execution,Deployment  &#x3D;&gt; Compiler &#x3D;&gt; Java Compiler </p>
<p>Project bytecode version 设置成11</p>
<p>jdk版本要适配,maven自动适配1.5版本,手动调成12(安装的版本) </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在IDEA报他不支持发行版本5的时候使用</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>12<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>12<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="1-6-Maven项目"><a href="#1-6-Maven项目" class="headerlink" title="1.6.Maven项目"></a>1.6.Maven项目</h2><h3 id="1-6-1-Maven项目的目录结构"><a href="#1-6-1-Maven项目的目录结构" class="headerlink" title="1.6.1.Maven项目的目录结构:"></a>1.6.1.Maven项目的目录结构:</h3><p>maven-project01<br>    |—  src  (源代码目录和测试代码目录)<br>            |—  main (源代码目录)<br>                       |— java (源代码java文件目录)<br>                       |— resources (源代码配置文件目录)<br>            |—  test (测试代码目录)<br>                       |— java (测试代码java目录)<br>                       |— resources (测试代码配置文件目录)<br>    |— target (编译、打包生成文件存放目录)</p>
<h3 id="1-6-2-pom文件标签"><a href="#1-6-2-pom文件标签" class="headerlink" title="1.6.2.pom文件标签:"></a>1.6.2.pom文件标签:</h3><ul>
<li><project> ：pom文件的根标签，表示当前maven项目</li>
<li><modelVersion> ：声明项目描述遵循哪一个POM模型版本<ul>
<li>虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0</li>
</ul>
</li>
<li>坐标 ：<groupId>、<artifactId>、<version><ul>
<li>定位项目在本地仓库中的位置，由以上三个标签组成一个坐标</li>
</ul>
</li>
<li><packaging> ：maven项目的打包方式，通常设置为jar或war（默认值：jar）</li>
</ul>
<h3 id="1-6-3-导入Maven项目"><a href="#1-6-3-导入Maven项目" class="headerlink" title="1.6.3.导入Maven项目"></a>1.6.3.导入Maven项目</h3><p>有两种导入方法</p>
<ol>
<li>从Maven面板点击＋号,选中导入项目的pom.xml文件</li>
<li>使用Project Structure进行导入</li>
</ol>
<h2 id="1-7-依赖相关"><a href="#1-7-依赖相关" class="headerlink" title="1.7.依赖相关"></a>1.7.依赖相关</h2><h3 id="1-7-1-依赖配置"><a href="#1-7-1-依赖配置" class="headerlink" title="1.7.1.依赖配置"></a>1.7.1.依赖配置</h3><p>pom.xml中的部分内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第1个依赖 : logback --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第2个依赖 : junit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在导入依赖之后点击Maven的刷新按钮</p>
<blockquote>
<p>注意事项：</p>
<ol>
<li>如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 &#x2F; 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待）</li>
<li>如果不知道依赖的坐标信息，可以到mvn的中央仓库（<a target="_blank" rel="noopener" href="https://mvnrepository.com/%EF%BC%89%E4%B8%AD%E6%90%9C%E7%B4%A2">https://mvnrepository.com/）中搜索</a></li>
</ol>
</blockquote>
<h3 id="1-7-2-依赖传递"><a href="#1-7-2-依赖传递" class="headerlink" title="1.7.2.依赖传递"></a>1.7.2.依赖传递</h3><ul>
<li>直接依赖<br>直接存在的依赖</li>
<li>间接依赖<br>直接存在的依赖的依赖</li>
</ul>
<h3 id="1-7-3-排除依赖"><a href="#1-7-3-排除依赖" class="headerlink" title="1.7.3.排除依赖"></a>1.7.3.排除依赖</h3><p>主动断开依赖的资源</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-projectB<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--排除依赖, 主动断开依赖的资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-7-4-依赖范围"><a href="#1-7-4-依赖范围" class="headerlink" title="1.7.4.依赖范围"></a>1.7.4.依赖范围</h3><p>根据pom.xml里面依赖包下面<scope></scope>包括的属性值</p>
<p>scope标签的取值范围：</p>
<table>
<thead>
<tr>
<th><strong>scope</strong>值</th>
<th><strong>主程序</strong></th>
<th><strong>测试程序</strong></th>
<th><strong>打包（运行）</strong></th>
<th><strong>范例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>compile（默认）</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>log4j</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>junit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>jdbc驱动</td>
</tr>
</tbody></table>
<h2 id="1-8-Maven三大生命周期"><a href="#1-8-Maven三大生命周期" class="headerlink" title="1.8.Maven三大生命周期"></a>1.8.Maven三大生命周期</h2><p>Maven拥有三套相互独立的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>,分别是clean、default和site.</p>
<h3 id="1-8-1-clean"><a href="#1-8-1-clean" class="headerlink" title="1.8.1.clean"></a>1.8.1.clean</h3><ol>
<li>clean Lifecycle： 在进行真正的构建之前进行一些清理工作。 mvn clean</li>
</ol>
<blockquote>
<p>clean的目的是清理项目。<br>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。有Clean生命周期，也有clean阶段。<br>包含3个阶段:<br>1.pre-clean 执行一些清理前需要完成的工作<br>2.clean 清理上一次构建过程中生成的文件，比如编译后的class文件等<br>3.post-clean 执行一些清理后需要完成的工作</p>
</blockquote>
<h3 id="1-8-2-default"><a href="#1-8-2-default" class="headerlink" title="1.8.2.default"></a>1.8.2.default</h3><ol>
<li>default Lifecycle： 构建的核心部分，编译，测试，打包，部署等等。</li>
</ol>
<blockquote>
<p><strong>generate-resources</strong>： 产生主代码中的资源在classpath中的包<br><strong>process-resource</strong>： 复制并处理资源文件，至目标目录，准备打包。<br><strong>compile</strong>： 编译项目的主源码.一般来说:编译src&#x2F;main&#x2F;java目录下的java文件至项目输出的主classpath目录中<br><strong>test-compile</strong>：编译项目的测试代码,是编译src&#x2F;test&#x2F;java目录下的java文件至项目输出的测试classpath目录中<br><strong>test</strong>： 使用单元测试框架运行测试,测试代码不会被打包或部署.<br><strong>package</strong>：打包成可发布的格式<br><strong>install</strong>：将包安装到Maven本地仓库,供本地其他Maven项目使用<br><strong>deploy</strong>：将最终的包复制到远程仓库,供其他开发人员和Maven项目使用</p>
</blockquote>
<p>PS：运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么我们运行mvn install 的时候，代码会被编译，测试，打包。此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理<br>解生命周期至关重要。</p>
<h3 id="1-8-3-site"><a href="#1-8-3-site" class="headerlink" title="1.8.3.site"></a>1.8.3.site</h3><ol>
<li>site Lifecycle： 生成项目报告，站点，发布站点。<br>目的：建立和发布项目站点</li>
</ol>
<blockquote>
<p><strong>pre-site</strong> 执行一些在生成项目站点之前需要完成的工作.<br><strong>site</strong> 生成项目站点文档<br><strong>post-site</strong> 执行一些在生成项目站点之后需要完成的工作.<br><strong>site-deploy</strong> 将生成的项目站点发布到服务器上</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/23/javaweb/maven/" data-id="clhzvhywc000oro8a1qx41n0w" data-title="maven" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javaweb/Vue(2)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/22/javaweb/Vue(2)/" class="article-date">
  <time class="dt-published" datetime="2023-05-22T10:21:11.000Z" itemprop="datePublished">2023-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/22/javaweb/Vue(2)/">Vue(2)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-Vue组件库Element"><a href="#1-Vue组件库Element" class="headerlink" title="1.Vue组件库Element"></a>1.Vue组件库Element</h1><h2 id="1-1-安装组件库"><a href="#1-1-安装组件库" class="headerlink" title="1.1.安装组件库:"></a>1.1.安装组件库:</h2><p>在vscode终端里面输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install element-ui@2.15.3</span><br></pre></td></tr></table></figure>

<p>然后在main.js入口文件中引入ElementUI的组件库</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>);</span><br></pre></td></tr></table></figure>

<p>再在View中抄写<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/">ElementUI的官网</a>的代码就可以了</p>
<h2 id="1-2-一些常用组件"><a href="#1-2-一些常用组件" class="headerlink" title="1.2.一些常用组件"></a>1.2.一些常用组件</h2><ul>
<li>Table</li>
<li>Pagination</li>
<li>Dialog</li>
<li>Form</li>
</ul>
<h3 id="补充-vue文件的相关知识"><a href="#补充-vue文件的相关知识" class="headerlink" title="补充:vue文件的相关知识"></a>补充:vue文件的相关知识</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  这里写框架,填充各种组件</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    //一般created()和mount()只需要一个</span><br><span class="line">	created() &#123;</span><br><span class="line">    //页面打开就执行,一般放首页的查询页面</span><br><span class="line">  &#125;, </span><br><span class="line">  mounted() &#123;</span><br><span class="line">    //在created之后执行</span><br><span class="line">    axios</span><br><span class="line">      .get(&quot;http://yapi.smart-xwork.cn/mock/169327/emp/list&quot;)</span><br><span class="line">      .then((resp) =&gt; &#123;</span><br><span class="line">        this.tableData = resp.data.data; //响应数据赋值给数据模型</span><br><span class="line">      &#125;);//this代表当前Vue对象</span><br><span class="line">  &#125;, </span><br><span class="line">  data() &#123;</span><br><span class="line">      //写全局数据</span><br><span class="line">    return &#123;</span><br><span class="line">      tableData: [],</span><br><span class="line">      searchForm: &#123;</span><br><span class="line">        name: &quot;&quot;,</span><br><span class="line">        gender: &quot;&quot;,</span><br><span class="line">        entrydate: [],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      //写触发方法</span><br><span class="line">    onSubmit: function () &#123;</span><br><span class="line">      console.log(this.searchForm);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleSizeChange(val) &#123;</span><br><span class="line">      console.log(`每页 $&#123;val&#125; 条`);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleCurrentChange(val) &#123;</span><br><span class="line">      console.log(`当前页: $&#123;val&#125;`);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    //和生命周期有关</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>具体的部件使用方法看官方文档就可以照葫芦画瓢</p>
<h2 id="1-3-路由"><a href="#1-3-路由" class="headerlink" title="1.3.路由"></a>1.3.路由</h2><p>在index.js中配置路由</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> emp <span class="keyword">from</span> <span class="string">&#x27;../views/tlias/EmpView.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> dep <span class="keyword">from</span> <span class="string">&#x27;../views/tlias/DeptView.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/emp&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;emp&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: emp</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/dep&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;dep&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: dep</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/emp&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>对应组件用route-link包裹</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-menu-item</span></span></span><br><span class="line"><span class="tag">                <span class="attr">index</span>=<span class="string">&quot;1-1&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">style</span>=<span class="string">&quot;background-color: rgb(212, 237, 223)&quot;</span></span></span><br><span class="line"><span class="tag">                &gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;dep&quot;</span>&gt;</span>部门管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">el-menu-item</span></span></span><br><span class="line"><span class="tag">                <span class="attr">index</span>=<span class="string">&quot;1-2&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">style</span>=<span class="string">&quot;background-color: rgb(212, 237, 223)&quot;</span></span></span><br><span class="line"><span class="tag">                &gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;emp&quot;</span>&gt;</span>员工管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span>&lt;/el-menu-item</span><br><span class="line">              &gt;</span><br></pre></td></tr></table></figure>

<p>修改调用位置,使用route-view自动调用</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;nav&gt;</span></span><br><span class="line"><span class="comment">      &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; |</span></span><br><span class="line"><span class="comment">      &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span></span><br><span class="line"><span class="comment">    &lt;/nav&gt;</span></span><br><span class="line"><span class="comment">    &lt;router-view/&gt;</span></span><br><span class="line"><span class="comment">  &lt;/div&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &#123;&#123;message&#125;&#125; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;element-view&gt;&lt;/element-view&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;emp-view&gt;你好&lt;/emp-view&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对应的index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到id &#x3D; “app”是主要调用</p>
<h1 id="2-打包部署"><a href="#2-打包部署" class="headerlink" title="2.打包部署"></a>2.打包部署</h1><p>点vscode里面的build会生成一个dist文件夹</p>
<p>把dist文件夹里面的东西放在tomcat里面的html就可以打开nginx.exe,然后查看配置软件的网址(默认是:<a href="http://localhost:80)就可以看到效果">http://localhost:80)就可以看到效果</a></p>
<p>如果80端口被占用，我们需要通过<strong>conf&#x2F;nginx.conf</strong>配置文件来修改端口号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">server&#123;</span><br><span class="line">	listen <span class="number">80</span>;<span class="comment">//把这里修改</span></span><br><span class="line">	server_name localhost;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="2-1-nginx"><a href="#2-1-nginx" class="headerlink" title="2.1.nginx"></a>2.1.nginx</h2><table>
<thead>
<tr>
<th>文件夹名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>conf</td>
<td>配置文件目录</td>
</tr>
<tr>
<td>html</td>
<td>静态资源文件目录</td>
</tr>
<tr>
<td>logs</td>
<td>日志文件目录</td>
</tr>
<tr>
<td>temp</td>
<td>临时文件目录</td>
</tr>
</tbody></table>
<p>nginx的安装目录一定无中文</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/22/javaweb/Vue(2)/" data-id="clhzvhyw9000fro8ae9zohmss" data-title="Vue(2)" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javaweb/Vue(1)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/19/javaweb/Vue(1)/" class="article-date">
  <time class="dt-published" datetime="2023-05-19T06:57:44.000Z" itemprop="datePublished">2023-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/19/javaweb/Vue(1)/">Vue(1)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-Vue概述"><a href="#1-Vue概述" class="headerlink" title="1.Vue概述"></a>1.Vue概述</h1><h2 id="1-1-一些概念"><a href="#1-1-一些概念" class="headerlink" title="1.1.一些概念"></a>1.1.一些概念</h2><h3 id="1-2-1-MVVM"><a href="#1-2-1-MVVM" class="headerlink" title="1.2.1.MVVM"></a>1.2.1.MVVM</h3><ul>
<li>Model: 数据模型，特指前端中通过请求从后台获取的数据</li>
<li>View: 视图，用于展示数据的页面，可以理解成我们的html+css搭建的页面，但是没有数据</li>
<li>ViewModel: 数据绑定到视图，负责将数据（Model）通过JavaScript的DOM技术，将数据展示到视图（View）上</li>
</ul>
<h3 id="1-2-2-Vue-js"><a href="#1-2-2-Vue-js" class="headerlink" title="1.2.2.Vue.js"></a>1.2.2.Vue.js</h3><p>Vue.js（读音 &#x2F;vjuː&#x2F;, 类似于 <strong>view</strong>） 是一套构建用户界面的 <strong>渐进式框架</strong>。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。Vue.js 的目标是通过尽可能简单的 API 实现<strong>响应的数据绑定</strong>和<strong>组合的视图组件</strong>。</p>
<h2 id="1-2-创建Vue对象"><a href="#1-2-创建Vue对象" class="headerlink" title="1.2.创建Vue对象"></a>1.2.创建Vue对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//定义Vue对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        el: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            message: <span class="string">&quot;Hello Vue&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在创建vue对象时，有几个常用的属性：</p>
<ul>
<li>el:  用来指定哪儿些标签受 Vue 管理。 该属性取值 <code>#app</code> 中的 <code>app</code> 需要是受管理的标签的id属性值</li>
<li>data: 用来定义数据模型</li>
<li>methods: 用来定义函数。这个我们在后面就会用到</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在html区域编写视图，其中&#123;&#123;&#125;&#125;是插值表达式，用来将vue对象中定义的model展示到页面上的</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="1-3-Vue指令"><a href="#1-3-Vue指令" class="headerlink" title="1.3.Vue指令"></a>1.3.Vue指令</h2><p>如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>v-bind</td>
<td>为HTML标签绑定属性值，如设置  href , css样式等</td>
</tr>
<tr>
<td>v-model</td>
<td>在表单元素上创建双向数据绑定</td>
</tr>
<tr>
<td>v-on</td>
<td>为HTML标签绑定事件</td>
</tr>
<tr>
<td>v-if</td>
<td>条件性的渲染某元素，判定为true时渲染,否则不渲染</td>
</tr>
<tr>
<td>v-else</td>
<td></td>
</tr>
<tr>
<td>v-else-if</td>
<td></td>
</tr>
<tr>
<td>v-show</td>
<td>根据条件展示某元素，区别在于切换的是display属性的值</td>
</tr>
<tr>
<td>v-for</td>
<td>列表渲染，遍历容器的元素或者对象的属性</td>
</tr>
</tbody></table>
<h3 id="1-3-1-v-bind和v-model"><a href="#1-3-1-v-bind和v-model" class="headerlink" title="1.3.1.v-bind和v-model"></a>1.3.1.v-bind和v-model</h3><h3 id="1-3-2-v-on"><a href="#1-3-2-v-on" class="headerlink" title="1.3.2.v-on"></a>1.3.2.v-on</h3><h3 id="1-3-3-v-if-和v-show"><a href="#1-3-3-v-if-和v-show" class="headerlink" title="1.3.3.v-if 和v-show"></a>1.3.3.v-if 和v-show</h3><h3 id="1-3-4-v-for"><a href="#1-3-4-v-for" class="headerlink" title="1.3.4.v-for"></a>1.3.4.v-for</h3><h2 id="1-4-生命周期"><a href="#1-4-生命周期" class="headerlink" title="1.4.生命周期"></a>1.4.生命周期</h2><h1 id="2-Ajax"><a href="#2-Ajax" class="headerlink" title="2.Ajax"></a>2.Ajax</h1><h2 id="2-1-Ajax作用"><a href="#2-1-Ajax作用" class="headerlink" title="2.1.Ajax作用"></a>2.1.Ajax作用</h2><ul>
<li>与服务器进行数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据。</li>
<li>异步交互：可以在<strong>不重新加载整个页面</strong>的情况下，与服务器交换数据并<strong>更新部分网页</strong>的技术，如：搜索联想、用户名是否可用的校验等等。</li>
</ul>
<h1 id="3-Axios"><a href="#3-Axios" class="headerlink" title="3.Axios"></a>3.Axios</h1><p>Axios是对原生的AJAX进行封装，简化书写</p>
<h2 id="3-1-使用方法"><a href="#3-1-使用方法" class="headerlink" title="3.1.使用方法"></a>3.1.使用方法</h2><ul>
<li><p>引入axios</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>发送 get 请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送 post 请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>method属性：用来设置请求方式的。取值为 get 或者 post。</p>
</li>
<li><p>url属性：用来书写请求的资源路径。如果是 get 请求，需要将请求参数拼接到路径的后面，格式为： url?参数名&#x3D;参数值&amp;参数名2&#x3D;参数值2。</p>
</li>
<li><p>data属性：作为请求体被发送的数据。也就是说如果是 post 请求的话，数据需要作为 data 属性的值。</p>
</li>
</ul>
<p>then() 需要传递一个匿名函数。我们将 then()中传递的匿名函数称为 <strong>回调函数</strong>，意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。而该回调函数中的 resp 参数是对响应的数据进行封装的对象，通过 resp.data 可以获取到响应的数据。</p>
<h2 id="3-2-Axios请求方法"><a href="#3-2-Axios请求方法" class="headerlink" title="3.2.Axios请求方法"></a>3.2.Axios请求方法</h2><p>Axios还针对不同的请求，提供了别名方式的api,具体如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>axios.get(url [, config])</td>
<td>发送get请求</td>
</tr>
<tr>
<td>axios.delete(url [, config])</td>
<td>发送delete请求</td>
</tr>
<tr>
<td>axios.post(url [, data[, config]])</td>
<td>发送post请求</td>
</tr>
<tr>
<td>axios.put(url [, data[, config]])</td>
<td>发送put请求</td>
</tr>
</tbody></table>
<h1 id="4-YAPI"><a href="#4-YAPI" class="headerlink" title="4.YAPI"></a>4.YAPI</h1><p>甲方和产品经理沟通,产品经理整理出接口文档交给前端后端分别开发,电子接口文档可以用YAPI代劳</p>
<h1 id="5-前端工程化"><a href="#5-前端工程化" class="headerlink" title="5.前端工程化"></a>5.前端工程化</h1><h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1.概念"></a>5.1.概念</h2><p>使用搭好的框架进行快速开发</p>
<h2 id="5-2-搭建环境"><a href="#5-2-搭建环境" class="headerlink" title="5.2.搭建环境"></a>5.2.搭建环境</h2><p>安装NodeJS和Vue-cli</p>
<h2 id="5-3-创建项目"><a href="#5-3-创建项目" class="headerlink" title="5.3.创建项目"></a>5.3.创建项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui //进入图形界面</span><br></pre></td></tr></table></figure>

<p>创建有路由的2.x,标准项目</p>
<h2 id="5-4-目录结构"><a href="#5-4-目录结构" class="headerlink" title="5.4.目录结构"></a>5.4.目录结构</h2><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>node_modules</td>
<td>依赖包</td>
</tr>
<tr>
<td>public</td>
<td>静态文件</td>
</tr>
<tr>
<td>src</td>
<td>存放源代码</td>
</tr>
<tr>
<td>package.json</td>
<td>模块基本信息</td>
</tr>
<tr>
<td>vue.config.js</td>
<td>保存vue配置版本号</td>
</tr>
</tbody></table>
<h2 id="5-5-运行方式"><a href="#5-5-运行方式" class="headerlink" title="5.5.运行方式"></a>5.5.运行方式</h2><p>两种方式</p>
<ol>
<li>使用VSCode提供的图形化界面<br>打开npm设置:<br>设置&#x2F;用户设置&#x2F;扩展&#x2F;MPM<br>点击<strong>资源管理器处的3个小点</strong>，<strong>勾选npm脚本选项</strong></li>
<li>命令行npm run serve</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/19/javaweb/Vue(1)/" data-id="clhzvhywb000kro8a46zpcf6s" data-title="Vue(1)" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-javase基础/4-集合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/16/javase%E5%9F%BA%E7%A1%80/4-%E9%9B%86%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2023-05-16T11:40:52.000Z" itemprop="datePublished">2023-05-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/16/javase%E5%9F%BA%E7%A1%80/4-%E9%9B%86%E5%90%88/">异常,集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h1><h2 id="1-1-异常分类"><a href="#1-1-异常分类" class="headerlink" title="1.1.异常分类"></a>1.1.异常分类</h2><p>-Java.lang.Throwable</p>
<p>​	-Error</p>
<p>​	-Exception</p>
<p>​		-RuntimeException</p>
<p>​		-其他异常</p>
<ul>
<li>Error是系统级别错误</li>
<li>Exception是异常,代表程序可能出现的问题</li>
<li>运行时异常:编译不会出现的异常</li>
<li>编译时异常:比那一阶段就会出现错误提醒的(日期解析异常)</li>
</ul>
<p>编译时异常解决方法:</p>
<ol>
<li>使用throws在方法上声明</li>
<li>使用try…catch处理异常</li>
</ol>
<h2 id="1-2-自定义异常"><a href="#1-2-自定义异常" class="headerlink" title="1.2.自定义异常"></a>1.2.自定义异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、必须让这个类继承自Exception，才能成为一个编译时异常类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在使用中throw new AgeIllegalException</p>
<h2 id="1-3-异常处理"><a href="#1-3-异常处理" class="headerlink" title="1.3.异常处理"></a>1.3.异常处理</h2><ol>
<li>在当前块进行try…catch处理</li>
<li>在外部块进行try…catch处理</li>
</ol>
<h1 id="2-集合-Collection"><a href="#2-集合-Collection" class="headerlink" title="2.集合(Collection)"></a>2.集合(Collection)</h1><h2 id="2-1-集合的分类"><a href="#2-1-集合的分类" class="headerlink" title="2.1.集合的分类"></a>2.1.集合的分类</h2><ul>
<li>Collection:单列集合顶层接口<br>List:有序,可重复,有索引<br>      ArrayList:底层数组<br>      LinkedList:底层链表<br>  Set:无序,不重复,没索引<br>      HashSet:底层哈希表<br>      TreeSet:底层红黑树<br>      LinkedHashSet:底层是双向链表 + 哈希表<br>Map:双列集合顶层接口<br>HashMap:底层哈希表<br>TreeMap:底层红黑树<br>LinkedHashMap:底层是双向链表 + 哈希表</li>
</ul>
<h2 id="2-2-Colloction方法"><a href="#2-2-Colloction方法" class="headerlink" title="2.2. Colloction方法"></a>2.2. Colloction方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//1.public boolean add(E e): 添加元素到集合</span></span><br><span class="line">c.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line"><span class="comment">//2.public int size(): 获取集合的大小</span></span><br><span class="line">System.out.println(c.size()); <span class="comment">//5</span></span><br><span class="line"><span class="comment">//3.public boolean contains(Object obj): 判断集合中是否包含某个元素</span></span><br><span class="line">System.out.println(c.contains(<span class="string">&quot;java1&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//4.pubilc boolean remove(E e): 删除某个元素，如果有多个重复元素只能删除第一个</span></span><br><span class="line">System.out.println(c.remove(<span class="string">&quot;java1&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//5.public void clear(): 清空集合的元素</span></span><br><span class="line">c.clear(); </span><br><span class="line"><span class="comment">//6.public boolean isEmpty(): 判断集合是否为空 是空返回true 反之返回false</span></span><br><span class="line">System.out.println(c.isEmpty()); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.public Object[] toArray(): 把集合转换为数组</span></span><br><span class="line">Object[] array = c.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.如果想把集合转换为指定类型的数组，可以使用下面的代码</span></span><br><span class="line">String[] array1 = c.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[c.size()]);</span><br><span class="line">System.out.println(Arrays.toString(array1)); </span><br><span class="line"><span class="comment">//9.还可以把一个集合中的元素，添加到另一个集合中</span></span><br><span class="line">Collection&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c1.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">c1.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c2.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">c2.add(<span class="string">&quot;java4&quot;</span>);</span><br><span class="line">c1.addAll(c2); <span class="comment">//把c2集合中的全部元素，添加到c1集合中去</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-遍历方法"><a href="#2-3-遍历方法" class="headerlink" title="2.3.遍历方法"></a>2.3.遍历方法</h2><ul>
<li><p>迭代器 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;灭绝&quot;</span>);</span><br><span class="line">System.out.println(c); <span class="comment">//[赵敏, 小昭, 素素, 灭绝]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步：先获取迭代器对象</span></span><br><span class="line"><span class="comment">//解释：Iterator就是迭代器对象，用于遍历集合的工具)</span></span><br><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：用于判断当前位置是否有元素可以获取</span></span><br><span class="line"><span class="comment">//解释：hasNext()方法返回true，说明有元素可以获取；反之没有</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">//第三步：获取当前位置的元素，然后自动指向下一个元素.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>并发修改异常:</p>
<p>在迭代器遍历的时候不允许使用集合的删除方法,使用迭代器的删除方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;王麻子&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;小李子&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;李爱花&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;张全蛋&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;晓李&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;李玉刚&quot;</span>);</span><br><span class="line">System.out.println(list); <span class="comment">// [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：找出集合中带&quot;李&quot;字的姓名，并从集合中删除</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;李&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//list.remove(name);</span></span><br><span class="line">        it.remove(); <span class="comment">//当前迭代器指向谁，就删除谁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>



<ul>
<li><p>增强for</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;灭绝&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.使用增强for遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(String s: c)&#123;</span><br><span class="line">    System.out.println(s); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.再尝试使用增强for遍历数组</span></span><br><span class="line">String[] arr = &#123;<span class="string">&quot;迪丽热巴&quot;</span>, <span class="string">&quot;古力娜扎&quot;</span>, <span class="string">&quot;稀奇哈哈&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String name: arr)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>foreach 可以对里面的参数进行处理之后输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;灭绝&quot;</span>);</span><br><span class="line"><span class="comment">//调用forEach方法</span></span><br><span class="line"><span class="comment">//由于参数是一个Consumer接口，所以可以传递匿名内部类</span></span><br><span class="line">c.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//也可以使用lambda表达式对匿名内部类进行简化</span></span><br><span class="line">c.forEach(s-&gt;System.out.println(s)); <span class="comment">//[赵敏, 小昭, 素素, 灭绝]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h1><p>有序,可重复,有索引</p>
<h2 id="3-1-List方法"><a href="#3-1-List方法" class="headerlink" title="3.1.List方法"></a>3.1.List方法</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index, E element)</td>
<td>在集合指定位置中插入</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定索引处的元素并返回被删除的元素</td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td>修改指定索引处的元素,返回被修改的元素</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody></table>
<h2 id="3-2-循环方式"><a href="#3-2-循环方式" class="headerlink" title="3.2.循环方式"></a>3.2.循环方式</h2><p>继承自collection的三种 + 普通for循环</p>
<h2 id="3-3-ArrayList底层原理"><a href="#3-3-ArrayList底层原理" class="headerlink" title="3.3.ArrayList底层原理"></a>3.3.ArrayList底层原理</h2><ol>
<li>基于数组实现,但是集合长度可变 - &gt; 查询慢,增删快</li>
</ol>
<blockquote>
<p>① 利用无参构造器创建的集合,会在底层创建一个默认长度为0的数组</p>
<p>②添加第一个元素时,底层会创建一个新的长度为10的数组</p>
<p>③存满时,会扩容1.5被</p>
<p>④如果依次添加多个元素,1.5倍也放不下,则长度扩容到新创建数组的长度</p>
</blockquote>
<p>数组扩容不是在原数组中扩容,是重新创建一新数组</p>
<h2 id="3-4-LinkedList底层原理"><a href="#3-4-LinkedList底层原理" class="headerlink" title="3.4.LinkedList底层原理"></a>3.4.LinkedList底层原理</h2><ol>
<li>基于双向链表实现 - &gt; 增删快,查询快</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void addFirsts(E e)</td>
<td>开头插入</td>
</tr>
<tr>
<td>void addLast(E e)</td>
<td>末尾插入</td>
</tr>
<tr>
<td>E getFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>E getLast()</td>
<td>返回最后一个</td>
</tr>
<tr>
<td>E removeFirst()</td>
<td>删除返回第一个</td>
</tr>
<tr>
<td>E removeLast()</td>
<td>删除返回最后一个</td>
</tr>
</tbody></table>
<h1 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h1><h2 id="4-1-分类"><a href="#4-1-分类" class="headerlink" title="4.1.分类"></a>4.1.分类</h2><ul>
<li>HashSet:无序,不重复,无索引</li>
<li>LinkedHashSet:有序,不重复,五索引</li>
<li>TreeSet: 排序,不重复,无索引</li>
</ul>
<h2 id="4-2-HashSet"><a href="#4-2-HashSet" class="headerlink" title="4.2.HashSet"></a>4.2.HashSet</h2><h3 id="4-2-1-底层原理"><a href="#4-2-1-底层原理" class="headerlink" title="4.2.1.底层原理:"></a>4.2.1.底层原理:</h3><ul>
<li>JDK8前: 哈希表 &#x3D; 数组 + 链表</li>
<li>JDK8后: 哈希表 &#x3D; 数组 + 链表 + 红黑树</li>
</ul>
<p>JDK8开始,当链表的长度超过8,就会把链表转换为红黑树</p>
<h3 id="4-2-2-去重原理"><a href="#4-2-2-去重原理" class="headerlink" title="4.2.2.去重原理"></a>4.2.2.去重原理</h3><ul>
<li>用hashCode确定底层数组中存储位置</li>
<li>用equals确认添加元素是否已存在</li>
</ul>
<h2 id="4-3-LinkedHashSet"><a href="#4-3-LinkedHashSet" class="headerlink" title="4.3.LinkedHashSet"></a>4.3.LinkedHashSet</h2><p>额外新增了一个双向列表来维护元素的存取顺序</p>
<h2 id="4-4-TreeSet"><a href="#4-4-TreeSet" class="headerlink" title="4.4.TreeSet"></a>4.4.TreeSet</h2><p>存储String和Integer类型的对象自带排序规则</p>
<p>存储自定义类型的元素需要自定义排序规则:</p>
<blockquote>
<p>第一种：让元素的类实现Comparable接口，重写compareTo方法</p>
</blockquote>
<blockquote>
<p>第二种：在创建TreeSet集合时，通过构造方法传递Compartor比较器对象</p>
</blockquote>
<h1 id="5-Colletions工具类"><a href="#5-Colletions工具类" class="headerlink" title="5.Colletions工具类"></a>5.Colletions工具类</h1><h2 id="5-1-方法"><a href="#5-1-方法" class="headerlink" title="5.1.方法"></a>5.1.方法</h2><ul>
<li><table>
<thead>
<tr>
<th>静态方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>addAll(集合,元素们)</td>
<td>批量添加元素</td>
</tr>
<tr>
<td>shuffle(List)</td>
<td>打乱List元素</td>
</tr>
<tr>
<td>sort(List)</td>
<td>升序排序</td>
</tr>
<tr>
<td>sort(List, Comparator)</td>
<td>用指定规则进行排序</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="6-Map"><a href="#6-Map" class="headerlink" title="6.Map"></a>6.Map</h1><h2 id="6-1-分类"><a href="#6-1-分类" class="headerlink" title="6.1.分类"></a>6.1.分类</h2><ol>
<li>HashMap:无序,不重复,无索引</li>
<li>LinkedHashMap:有序,不重复,无索引</li>
<li>TreeMap:升序排序,不重复,无索引</li>
</ol>
<h2 id="6-2-Map集合方法"><a href="#6-2-Map集合方法" class="headerlink" title="6.2.Map集合方法"></a>6.2.Map集合方法</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>put(key,value)</td>
<td>添加</td>
</tr>
<tr>
<td>size()</td>
<td>返回集合大小</td>
</tr>
<tr>
<td>clear()</td>
<td>清空集合</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断是否空</td>
</tr>
<tr>
<td>get(Object)</td>
<td>返回键值对应值</td>
</tr>
<tr>
<td>remove(Object)</td>
<td>根据键删除元素</td>
</tr>
<tr>
<td>containsKey(Object)</td>
<td>判断是否包含某个键</td>
</tr>
<tr>
<td>containsValue(Object)</td>
<td>判断是否包含某个值</td>
</tr>
<tr>
<td>Set<K> keySet()</td>
<td>获得全部键的集合</td>
</tr>
<tr>
<td>Collection<V> values()</td>
<td>获得全部值的结合</td>
</tr>
</tbody></table>
<h2 id="6-3-遍历方法"><a href="#6-3-遍历方法" class="headerlink" title="6.3.遍历方法"></a>6.3.遍历方法</h2><ul>
<li>键找值</li>
<li>值找键</li>
<li>forEach(new BiConsumer)</li>
</ul>
<h2 id="6-4-HashMap"><a href="#6-4-HashMap" class="headerlink" title="6.4.HashMap"></a>6.4.HashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HashMap底层数据结构: 哈希表结构</span><br><span class="line">	JDK8之前的哈希表 = 数组+链表</span><br><span class="line">	JDK8之后的哈希表 = 数组+链表+红黑树</span><br><span class="line">	哈希表是一种增删改查数据，性能相对都较好的数据结构</span><br><span class="line">	</span><br><span class="line">往HashMap集合中键值对数据时，底层步骤如下</span><br><span class="line">	第<span class="number">1</span>步：当你第一次往HashMap集合中存储键值对时，底层会创建一个长度为<span class="number">16</span>的数组</span><br><span class="line">	第<span class="number">2</span>步：把键然后将键和值封装成一个对象，叫做Entry对象</span><br><span class="line">	第<span class="number">3</span>步：再根据Entry对象的键计算hashCode值（和值无关）</span><br><span class="line">	第<span class="number">4</span>步：利用hashCode值和数组的长度做一个类似求余数的算法，会得到一个索引位置</span><br><span class="line">	第<span class="number">5</span>步：判断这个索引的位置是否为<span class="literal">null</span>，如果为<span class="literal">null</span>,就直接将这个Entry对象存储到这个索引位置</span><br><span class="line">		   如果不为<span class="literal">null</span>，则还需要进行第<span class="number">6</span>步的判断</span><br><span class="line">	第<span class="number">6</span>步：继续调用equals方法判断两个对象键是否相同</span><br><span class="line">		  如果equals返回<span class="literal">false</span>，则以链表的形式往下挂</span><br><span class="line">		  如果equals方法<span class="literal">true</span>,则认为键重复，此时新的键值对会替换就的键值对。</span><br><span class="line">	</span><br><span class="line">HashMap底层需要注意这几点：</span><br><span class="line">	<span class="number">1.</span>底层数组默认长度为<span class="number">16</span>，如果数组中有超过<span class="number">12</span>个位置已经存储了元素，则会对数组进行扩容<span class="number">2</span>倍</span><br><span class="line">	  数组扩容的加载因子是<span class="number">0.75</span>，意思是：<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span> 	</span><br><span class="line">   	</span><br><span class="line">    <span class="number">2.</span>数组的同一个索引位置有多个元素、并且在<span class="number">8</span>个元素以内(包括<span class="number">8</span>)，则以链表的形式存储</span><br><span class="line">    	JDK7版本：链表采用头插法（新元素往链表的头部添加）</span><br><span class="line">    	JDK8版本：链表采用尾插法（新元素我那个链表的尾部添加）</span><br><span class="line">    	</span><br><span class="line">    <span class="number">3.</span>数组的同一个索引位置有多个元素、并且超过了<span class="number">8</span>个，则以红黑树形式存储</span><br></pre></td></tr></table></figure>

<h2 id="6-5-LinkedHashMap"><a href="#6-5-LinkedHashMap" class="headerlink" title="6.5.LinkedHashMap"></a>6.5.LinkedHashMap</h2><p>多维护一个双向链表</p>
<h2 id="6-6-TreeMap"><a href="#6-6-TreeMap" class="headerlink" title="6.6.TreeMap"></a>6.6.TreeMap</h2><ul>
<li><p>TreeMap集合的特点也是由键决定的，默认按照键的升序排列，键不重复，也是无索引的。</p>
</li>
<li><p>TreeMap集合的底层原理和TreeSet也是一样的，底层都是红黑树实现的。所以可以对键进行排序。</p>
</li>
</ul>
<h1 id="7-Stream流操作"><a href="#7-Stream流操作" class="headerlink" title="7.Stream流操作"></a>7.Stream流操作</h1><h2 id="7-1-创建Stream流"><a href="#7-1-创建Stream流" class="headerlink" title="7.1.创建Stream流"></a>7.1.创建Stream流</h2><p>方法:</p>
<ul>
<li>List.stream()</li>
<li>Set.stream()</li>
<li>Map<br>Map.keySet().stream()<br>Map.values().stream()<br>Map.entrySet().stream()</li>
<li>Arrays.stream()</li>
<li>Stream.of()</li>
</ul>
<h2 id="7-2-中间方法"><a href="#7-2-中间方法" class="headerlink" title="7.2.中间方法"></a>7.2.中间方法</h2><table>
<thead>
<tr>
<th>中间方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>filter</td>
<td>过滤</td>
</tr>
<tr>
<td>sorted</td>
<td>升序排序</td>
</tr>
<tr>
<td>sorted</td>
<td>用 Comparator排序</td>
</tr>
<tr>
<td>limit</td>
<td>获取前几个</td>
</tr>
<tr>
<td>skip</td>
<td>跳过前几个</td>
</tr>
<tr>
<td>distinct</td>
<td>去重</td>
</tr>
<tr>
<td>map</td>
<td>元素加工返回新的流对象</td>
</tr>
<tr>
<td>concat</td>
<td>合并流</td>
</tr>
</tbody></table>
<h2 id="7-3-终结方法"><a href="#7-3-终结方法" class="headerlink" title="7.3.终结方法"></a>7.3.终结方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>forEach</td>
<td>对流运算后的元素进行遍历</td>
</tr>
<tr>
<td>count</td>
<td>返回运算后的元素个数</td>
</tr>
<tr>
<td>max</td>
<td>返回最大值 可以传比较器</td>
</tr>
<tr>
<td>min</td>
<td>返回最小值 可以传比较器</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/16/javase%E5%9F%BA%E7%A1%80/4-%E9%9B%86%E5%90%88/" data-id="clhzvhyw7000bro8a4qet542l" data-title="异常,集合" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaSE/" rel="tag">JavaSE</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaSE/">JavaSE</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaSE/" rel="tag">JavaSE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/" rel="tag">基础阶段</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaSE/" style="font-size: 20px;">JavaSE</a> <a href="/tags/JavaWeb/" style="font-size: 10px;">JavaWeb</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/" style="font-size: 15px;">基础阶段</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/28/javase%E5%9F%BA%E7%A1%80/junit-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/">junit-反射-注解</a>
          </li>
        
          <li>
            <a href="/2023/05/26/javase%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">线程池_网络编程</a>
          </li>
        
          <li>
            <a href="/2023/05/25/javaweb/springboot%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/">springboot请求响应</a>
          </li>
        
          <li>
            <a href="/2023/05/24/javase%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B/">多线程</a>
          </li>
        
          <li>
            <a href="/2023/05/24/javaweb/SpringBoot/">SpringBoot</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Kevin Yang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>